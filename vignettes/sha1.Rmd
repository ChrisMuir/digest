---
title: "Calculating SHA1 hashes with digest() and sha1()"
author: "Thierry Onkelinx, Dirk Eddelbuettel"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sha1() versus digest()}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

- short intro on hashes

## Difference between `digest()` and `sha1()`

- FAQ 7.31
- `digest()` uses the data as is
    - numeric values are stored differently on 32-bit and 64-bit systems.
- `sha1()` truncates numeric values after a certain number of digits
    - the number of digits needs to be small enough to get the same hash on 32-bit and 64-bit
    - the number of digits needs to be high enough to get a different hash when the difference between values is relevant

## Choosing `digest()` or `sha1()`

## Creating a sha1 method for other classes

- lm
- glm

## Using hashes to track changes in analysis

use case

- automated analysis
- update frequency of the data might be lower than the frequency of automated analysis
- similar analyses on many datasets (e.g. many species in ecology)
- analyses that require a lot of computing time
    - not rerunning an analysis because nothing has changed saves enough resources to compensate the overhead of tracking changes

- Bundle all relevant information on an analysis in a class
    - data
    - method
    - formula
    - other metadata
    - resulting model
- calculate `sha1()`

    file fingerprint
      ~ `sha1()` on the stable parts
    
    status fingerprint
      ~ `sha1()` on the parts that result for the model

1. Prepare analysis objects
1. Store each analysis object in a rda file which uses the file fingerprint as filename
    - File will already exist when no change in analysis
    - Don't overwrite existing files
1. Loop over all rda files
    - Do nothing if the analysis was run
    - Otherwise run the analysis and update the status and status fingerprint
