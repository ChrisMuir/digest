---
title: "Calculating SHA1 hashes with digest() and sha1()"
author: "Thierry Onkelinx, Dirk Eddelbuettel"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{sha1() versus digest()}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

- short intro on hashes

## Difference between `digest()` and `sha1()`

- FAQ 7.31
- `digest()` uses the data as is
    - numeric values are stored differently on 32-bit and 64-bit systems.
- `sha1()` truncates numeric values after a certain number of digits
    - the number of digits needs to be small enough to get the same hash on 32-bit and 64-bit
    - the number of digits needs to be high enough to get a different hash when the difference between values is relevant

## Choosing `digest()` or `sha1()`

## Creating a sha1 method for other classes

### How to

1. Identify the relevant components for the hash.
1. Determine the class of each relevant component and check if they are handled by `sha1()`.
    - Write a method for each component class not yet handled by `sha1`.
1. Extract the relevant components.
1. Combine the relevant components into a list. Not required in case of a single component.
1. Apply `sha1()` on the (list of) relevant component(s).
1. Turn this into a function with name sha1._classname_.
1. sha1._classname_ needs exactly the same arguments as `sha1()`
1. Choose sensible defaults for the arguments
    - `zapsmall = 7` is recommended.
    - `digits = 14` is recommended in case all numerics are data.
    - `digits = 4` is recommended in case some numerics stem from floating point arithmetic.

###  summary.lm

Let's illustrate this using the summary of a simple linear regression. Suppose that we want a hash that takes into account the coefficients, their standard error and sigma.

```{r sha1_lm_sum}
# taken from the help file of lm.influence
lm_SR <- lm(sr ~ pop15 + pop75 + dpi + ddpi, data = LifeCycleSavings)
lm_sum <- summary(lm_SR)
class(lm_sum)
# str() gives the structure of the lm object
str(lm_sum)
# extract the coefficients and their standard error
coef_sum <- coef(lm_sum)[, c("Estimate", "Std. Error")]
# extract sigma
sigma <- lm_sum$sigma
# check the class of each component
class(coef_sum)
class(sigma)
# sha1() has methods for both matrix and numeric
library(digest)
# because the values originate from floating point arithmetic it is better to use a low number of digits
sha1(coef_sum, digits = 4)
sha1(sigma, digits = 4)
# we want a single hash
# combining the components in a list is a solution that works
sha1(list(coef_sum, sigma), digits = 4)
# now turn everything into an S3 method
#   - a function with name "sha1.classname"
#   - must have the same arguments as sha1()
sha1.summary.lm <- function(x, digits = 4, zapsmall = 7){
    coef_sum <- coef(x)[, c("Estimate", "Std. Error")]
    sigma <- x$sigma
    combined <- list(coef_sum, sigma)
    sha1(combined, digits = digits, zapsmall = zapsmall)
}
sha1(lm_sum)
```

## Using hashes to track changes in analysis

use case

- automated analysis
- update frequency of the data might be lower than the frequency of automated analysis
- similar analyses on many datasets (e.g. many species in ecology)
- analyses that require a lot of computing time
    - not rerunning an analysis because nothing has changed saves enough resources to compensate the overhead of tracking changes

- Bundle all relevant information on an analysis in a class
    - data
    - method
    - formula
    - other metadata
    - resulting model
- calculate `sha1()`

    file fingerprint
      ~ `sha1()` on the stable parts
    
    status fingerprint
      ~ `sha1()` on the parts that result for the model

1. Prepare analysis objects
1. Store each analysis object in a rda file which uses the file fingerprint as filename
    - File will already exist when no change in analysis
    - Don't overwrite existing files
1. Loop over all rda files
    - Do nothing if the analysis was run
    - Otherwise run the analysis and update the status and status fingerprint
